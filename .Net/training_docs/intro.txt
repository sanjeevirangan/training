Notes on .Net training

.Net Need

->  Distributed applications 

->  Language interoperability (52 languages)
->  Languages are converted to CIL (comon Intermediate language)
->  No dll hell



CLR components:

-> Type loader
-> Type verifier (CTS)
-> JIT Compiler
-> Garbage Collector
-> COM interop
-> Security


Garbage Collector:

-> Mark (Idle memeory)
-> Sweep (Remove the idle object)


Interops:

CCW: com callable wrapper (legacy dll in .Net apps)
RCW: Remote callable wrapper (.Net dll in legacy apps)


Security:

Authentication, authorization, permissions
.config (xml format)
-> Machine.config
-> App.config (Windows, WPF)
-> web.config (web, MVC)





Evolution:

.NEt 3.5 -2008- New Features
-> Implicit variables, Extension method, Anonymus types,
Lambda expressions, LiNQ, Automatic property, Property initializer. colelction

.Net 4.0 -2010- VS 2010

-> dynamic variables, task parallel library, Interop with Ruby scripts, covariance and contravariance,
named and optional param



.Net 4.5 VS2012

-> async and await, WPF enhancements in wpf, wcf, MVC 4.0, web API 1.0


.Net 5.0 VS 2013

-> MVC 5.0, entity framework 6.2, Web API 2.1





C#

-> case sensitive
-> Supoorts oops
-> extension .cs
-> /* multiline comments */
-> // single line coments
-> no pointers (*, &) instead keywords like this, ref, out 



IDE-> solution-> has multiple projects

libraries are called as namespace -> "using system"

comandline arguements -> string array

namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
        }
    }
}




Datatypes:


-> numberbased
	-> double 3.14
	-> float 3.14f
	-> decimal 3.14M	

-> char based
	-> char ''
	-> string ""
-> others


Conversion:

-> Parse - converts string to other datatype
-> Convert - converts datatype to other types ( usually 18)


Operators:

-> Arithematic operators -> numerical datatypes: + - * / %

-> Relational operators: > <= >= != ==

-> Logical operators:  && || !

-> Assignment operator: = += -= *= /= %=

-> unary operator: ++ --

-> ternary operator c = a>b ? 10:12;






conditional constructs:

-> if else:
	

-> switch: break is for each statement unlike other languages




looping constructs:

-> while: check for condition and execute

-> do while: execute aleast once then check

-> for: initialization, condition, iterator

-> foreach: iterates the loop. No condition involved

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Day 02:

OOps concepts:

-> Data Abstraction:
	-> Access specifiers: 
		-> Public (even with diff solutions)
		-> private (only within class)
		-> protected (only inherited class)
		-> internal (namespace scope)
		-> By default a class is "internal"
		-> By default variables, methods, properties, constructs are private.
		-> Public is the highest access scope.


-> Encapsulation:
	-> Defining variables, properties, methods inside class is called Encapsulation (data hiding)
	-> Class: Blueprint of Object. User defined type. Inherited from the parent class "Object"
	-> Object: Instance of a class. Class variable created during runtime. "new" keyword creates memory in heap for the instantiated object.
	-> constructor: 
		-> Invoked when creating object of the class.
		-> default constructor (by CLR): 
			-> intializes numerical type to 0 and string types to blank(null)
			-> Can be written by programmers with no parmaters. But only one default constructor.
		-> parameteralized constructor: 
			-> name should be same as constructor and has no return type. 
			-> Overrides default constructor.
			-> can be multiple parameterized constructor. (this is polymorphism - constructor overloading)
		-> Based on Access specifiers:
			-> public constructor
			-> static constructor:
				-> If only static variable is used.
			-> private constructor:
				-> Used for a singleton pattern
		-> 'this' keyword used to point the class variables. Useful when there is ambiguity in the variable names.
		


-> Inheritance:

-> Polymorphism:
	-> Many forms, overloading
	-> Static polymorphism:
		-> constructor, method, operator overloading
	-> dynamic(runtime) polymorphism:
		-> method overriding (through inheritance)


Memory management:

-> Heap: 
	-> refence type

-> Stack: 
	-> value type (primitive data types)

-> Destructor:
	-> same name as class name. Begins with ~ 
	-> has no return type.
	-> Always public
	-> Cannot be overloaded.
	-> Last function to be called automatically at the end of the application


Methods:
	-> Possibilities:
		-> No return type, no parameters
		-> No return type, has parmaters
		-> has return type, no parametrs
		-> has return type, has parameters


Operator Overloading:

	-> Primitive numerical datatype: + - * / % 
		-> Operator overloading method has to be static.
		-> Cannot return void
		-> If relational operators are overloaded, they are to be overloaded in pairs.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




